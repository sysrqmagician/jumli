<!DOCTYPE html>
<html>
<head>
    <title>JuMLi</title>
    <meta property="og:title" content="JuMLi: Judge My List"></meta>
    <meta property="description" content="Get automated feedback on your RimWorld modlist"></meta>
    <meta property="og:description" content="Get automated feedback on your RimWorld modlist"></meta>
    <meta property="og:url" content="https://jumli.sysrqmagician.dev"></meta>
    <link rel="stylesheet" href="/index.css"></link>
</head>

<body>
    <noscript><strong>Automatic modlist checking requires JavaScript. You can still look up individual mods as detailed on the Quick Lookup page.</strong></noscript>
    <h1>Judge My List</h1>
    <nav>
        <a href="/rentry.html">From Rentry</a>
        <a href="/quick.html">Quick Lookup</a>
       <a href="https://github.com/sysrqmagician/jumli">GitHub Repository</a>
    </nav>
    <p>Get automated feedback on your RimWorld modlist</p>
    <details>
        <summary>How do I use this?</summary>
        <ol>
            <li>Open RimSort. If you don't already use it, you should <a href="https://rimsort.github.io/RimSort/user-guide/downloading-and-installing">get it</a>. Using the in-game mod sorting function might cause issues.
              <ul>
                <li>If you are already using RimPy, you should replace it with RimSort. RimPy has been unmaintained for some time and is known to cause issues due to bad sorting and malformed DDS textures.</li>
              </ul>
            </li>
            <li>
                Click <strong>File > Export > To Clipboard...</strong> in the main toolbar to copy your modlist in the required format.
                <br />
                <img src="/img/export2clip.png"></img>
            </li>
            <li>Paste the list into the text field below and click 'Submit'</li>
            <li>After your list is processed, read and carefully consider the notes presented to you.</li>
        </ol>
    </details>
    <br />
    <div id="input_area">
    <textarea id="list_input" placeholder="Paste your list here!"></textarea>
    <button id="submit_button">Submit</button>
    </div>
    <div id="errors_container" hidden="">
      <details open="">
        <summary>Drats! JuMLi encountered an issue while processing your list. Results may be incomplete.</summary>
        <p>Please <a href="https://github.com/sysrqmagician/jumli/issues/new">create an issue on GitHub</a> and include the following logs as well as your modlist (exported to clipboard).</p>
        <textarea id="logs_ta"></textarea>
      </details>
    </div>
    <div id="loading" hidden="">
        <div class="spinner_container">
            <div class="spinner"></div>
            <p id="loading_label"></p>
        </div>
    </div>
    <div id="results" hidden="">
    </div>

    <script>
    function present() {
      loading.setAttribute("hidden", true);
      results.removeAttribute("hidden");
    }

    function present_errors(logs) {
      logs_ta.value = logs.join('\n');
      errors_container.removeAttribute("hidden");
      logs_ta.style.height = `${logs_ta.scrollHeight}px`;
    }

    submit_button.addEventListener("click", async (e) => {
      let logs = [`[INFO] Started at ${new Date().toString()}.`];

        input_area.setAttribute("hidden", true);
        loading.removeAttribute("hidden");

        loading_label.textContent = "Parsing list...";

        const input_lines = list_input.value.split("\n")
        if (!input_lines) {
          results.textContent = "Provided list was invalid (null). Read the instructions, then refresh and try again.";
          present();
          return;
        }
        const list_start = input_lines.findIndex((x) => x === "") + 1;

        if (list_start === 0) {
          results.textContent = "Provided list was invalid (could not find start). Read the instructions, then refresh and try again.";
          present();
          return;
        }

        logs.push(`[INFO] Input consists of ${input_lines.length} lines. List starts at index ${list_start}.`)

        const mod_specs = input_lines.slice(list_start)
        const spec_regex = new RegExp(/(.*) (\[.*\])(\[.*\])/);
        let mods = [];
        let errors = 0;

        for (i in mod_specs) {
          const spec = mod_specs[i];
          const match = spec.match(spec_regex);

          if (!match || match.length < 4) {
            logs.push(`[ERROR] Spec line did not match expected format: ${spec}`);
            errors += 1;
            continue;
          }

          const name = match[1];
          const package_id = match[2].slice(1, -1);
          const url = match[3].slice(1, -1);

          let workshop_id = null;
          try {
            const parsed_url = new URL(url);
            if (parsed_url && parsed_url.hostname === "steamcommunity.com" && parsed_url.searchParams) {
              workshop_id = parsed_url.searchParams.get("id");
            }
          } catch (_) {
            // expected, local mods list invalid urls. log and ignore
            logs.push(`[WARNING] The following spec included a malformed workshop URL: ${spec}`);
          }

          mods.push([name, package_id, workshop_id]);
        }
        loading_label.textContent = "Fetching index...";

        let index_response;
        try {
          index_response = await fetch("/mods/index.json");
        } catch(e) {
          logs.push(`[ERROR] Could not fetch index: ${e.toString()}`);
          present_errors(logs);
        }

        if (!index_response || !index_response.ok) {
          results.textContent = `Unable to fetch index. Please do not report this issue on GitHub, it is almost certainly caused by connectivity issues on your end. A browser plug-in may be blocking JuMLi's requests.`;
          present();
          return;
        }

        
        let index;
        try {
          index = await index_response.json();
        } catch (e) {
          logs.push(`[ERROR] Could not parse index: ${e.toString()}`);
          present_errors(logs);
        }

        if (!index) {
          results.textContent = `Unable to read index. `;
          present();
          return;
        }

        let foundAnything = false;
        loading_label.textContent = "Looking for notices...";
        for (i in mods) {
          const mod = mods[i];
          let internal_id = null;

          // Attempt to find by package id
          internal_id = index[mod[1]];

          // Attempt to find by workshop id
          if (internal_id == null) {
            internal_id = index[mod[1]];
          }

          if (internal_id == null) {
            continue;
          }

          foundAnything = true;

          let hr = document.createElement("hr");
          results.appendChild(hr);

          let title = document.createElement("h3");
          title.textContent = mod[0];
          results.appendChild(title);

          let frame = document.createElement("iframe");
          frame.setAttribute("src", `/mods/${internal_id}.html`);
          frame.setAttribute("frameBorder", "0");
          results.appendChild(frame);
        }

        if (!foundAnything) {
          results.textContent = "Nothing to report!";
        }

        if (errors !== 0 || window.location.hash && window.location.hash.substr(1) === "showlog") {
          present_errors(logs);
        }

        present();
    });
    </script>

    <iframe src="/footer.html" width="100%" frameBorder="0"></iframe>
</body>

</html>
